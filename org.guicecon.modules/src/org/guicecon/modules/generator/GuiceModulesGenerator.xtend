/*
 * generated by Xtext
 */
package org.guicecon.modules.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.guicecon.modules.guiceModules.Module
import org.eclipse.xtext.xbase.compiler.StringBuilderBasedAppendable
import org.eclipse.xtext.xbase.compiler.XbaseCompiler
import org.eclipse.xtext.xbase.compiler.IAppendable
import org.guicecon.modules.guiceModules.Binding
import org.eclipse.xtext.xbase.compiler.ImportManager
import org.guicecon.modules.guiceModules.Key
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.emf.ecore.EObject

class GuiceModulesGenerator implements IGenerator {
	
	@Inject extension ModuleExtensions
	@Inject XbaseCompiler
	@Inject TypeReferences
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val m = resource.contents.head as Module
		fsa.generateFile(m.javaPath, m.generateJava)
	}
	
	generateJava(Module m) {
		val im = new ImportManager(true)
		val sb = new StringBuilder()
		im.registerType("java.util.HashSet", m)
		im.registerType("java.util.Set", m)
		
		im.registerType("com.google.inject.Binder", m)
		im.registerType("com.google.inject.Key", m)
		im.registerType("com.google.inject.Module", m)
		im.registerType("com.google.inject.TypeLiteral", m)
				
		val contents = m.generate(im)
		return '''
			package «m.packageName»;
			
			«FOR imp : im.imports»
				import «imp»;
			«ENDFOR»
			
			«contents»
		'''
	}
	
	registerType(ImportManager m, String typeSignature, EObject context) {
		val typeRef = typeReferences.getTypeForName(typeSignature, context)
		m.appendTypeRef(typeRef,new StringBuilder())
		return m
	}
	
	dispatch generate(Module m, ImportManager im) '''
		@SuppressWarnings("all")
		public class «m.name» implements Module {
			
			«FOR mixedIn : m.mixins»
				private «mixedIn.qualifiedName» «mixedIn.name.toFirstLower» = new «mixedIn.qualifiedName»(); 
			«ENDFOR»
			
			public void configure(Binder binder) {
				configure(binder, new HashSet<Key<?>>());
			}
			
			public void configure(Binder binder, Set<Key<?>> usedKeys) {
				«FOR b : m.bindings»
					«b.generate(im)»
				«ENDFOR»
				«FOR mixedIn : m.mixins»
					«mixedIn.name.toFirstLower».configure(binder, usedKeys); 
				«ENDFOR»
			}
		}
	'''
	
	dispatch generate(Binding b, ImportManager im) {
		val sb = new StringBuilderBasedAppendable(im)
		sb.append("\nif (usedKeys.add(")
		b.from.appendKey(sb)
		sb.append(")) {")
		sb.increaseIndentation
		if (b.toInstance!=null) 
			b.toInstance.prepare(sb)
		sb.append("\nbinder.bind(")
		b.from.appendKey(sb)
		sb.append(")")
		if (b.to!=null) {
			sb.append(".to(")
			b.to.appendKey(sb)
			sb.append(")")
		} else {
			sb.append(".toInstance(")
			b.toInstance.toExpression(sb)
			sb.append(")")
		}
		sb.append(";")
		sb.decreaseIndentation
		sb.append("\n}")
	}
	
	void appendKey(Key k, IAppendable sb) {
		sb.append("Key.get(");
		sb.append("new TypeLiteral<")
		sb.append(k.type).append(">(){}");
		if (k.annotation?.annotation!=null) {
			sb.append(",").append(k.annotation.annotation).append(".class")
		}
		sb.append(")")
	}
	
	void prepare(XExpression expr, IAppendable app) {
		if (expr!=null) {
			xbaseCompiler.toJavaStatement(expr, app, true)
		}
	}
	
	void toExpression(XExpression expr, IAppendable app) {
		if (expr!=null) {
			xbaseCompiler.toJavaExpression(expr, app)
		}
	}
}
